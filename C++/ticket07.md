## Билет 07
Автор: Денис Филиппов

* Синтаксис и пример
	* Появилась возможность наследовать одну структуру / класс от нескольких. Пример:

		``` C++
		struct PieceOfArt { std::chrono::time_point date; };      
		struct Music : PieceOfArt { std::string notes; };
		struct Lyrics : PieceOfArt { ... };
		struct Song : Music, Lyrics {
		Song(...) : Music(...), Lyrics(...), album(...) {}
		std::string album;
		// using Music::date;
		};
		```

	* Синтаксис как в обычном наследовании, только теперь мы через запятую перечисляем несколько предков.

	* Если возникает пересечение по именам, при обращении добавляем квалификатор. Если пересечений нет, то как обычно:

		``` C++
		Song s;
		x = s.Music::date;
		y = s.Lyrics::date;
		z = s.notes;
		```

	* Если есть `using Music::date`, то можно через `.` обращаться к date без `Music::`

		``` C++
		x = s.date;
		```

* Возможное представление в памяти, пример изменения адреса при `static_cast`

	* Возможное представление в памяти: сначала идут базовые объекты в порядке объявления (возможно с повторениями, в примере `PieceOfArt` повторится внутри `Music` и `Lyrics`), потом свои поля (в примере -- `album`).

  * Когда делаем `static_cast` (например, `static_cast<Lyrics *>(&s)`), меняется адрес указателя. Почему? Раньше у нас всегда был один предок, он располагался в начале куска памяти, потом шли поля. Поэтому первый байт у наследника и первый байт у предка совпадали. Теперь же, если мы кастуем к подобъекту, который не первый в памяти, указатель сдвинется до этого подобъекта.


* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам

	* Сначала инициализируются базовые объекты, причем в том порядке, в котором они указаны в объявлении класса (получается своеобразный dfs, т.к. заходим в первый базовый класс, у него заходим в первый базовый класс и т.д.). После этого как обычно (в порядке объявляния) инициализируются поля. Параметры конструкторам базовых классов передаются через запятую.

	* Уничтожение происходит в обратном порядке.


* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа.

	* Нельзя кастовать напрямую `Song` к `PieceOfArt`. Это происходит из-за того что в `Song` хранятся два экземпляра `PieceOfArt` и возникает ситуация ambiguous base: непонятно к какому экземпляру кастовать. Сначала нужно прикастовать к `Music` / `Lyrics`, и только потом к `PieceOfArt` (в общем случаи также, на примере понятнее).
