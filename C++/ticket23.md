## Билет 23
Автор: Валера Головин
### Оборачивание кода библиотечным
#### `std::reference_wrapper`
Поставим 3 задачи и найдем из решение
1. Ссылки в C++ не могут выступать в качестве типа элементов массива или контейнера STL:
2. Инициализация ссылки происходит при её объявлении. После объявления ссылки её невозможно привязать к другой переменной.
3. Многие алгоритмы в STL могут принимать функторы (функциональные объекты) в качестве своих аргументов. Передача аргументов алгоритму, в том числе и функторов, происходит по значению. Это затрудняет использование внутреннего состояния функторов. К примеру: как подсчитать количество операций сравнения в алгоритме `std::sort`?
#### Решение 3 задачи -- `std::ref` и `std::cref`
```cpp
template<typename T>
struct SortPredicate {
    // Счетчик
    uint64_t count = 0;
    
    bool operator()(T a, T b) {
        ++count; 
        return a < b;
    }
};

std::vector<int> v = {7,3,8,5,4,6,1,9,2};

// Создаем функтор-предикат, который считает "сравнения"
SortPredicate<int> p;

std::sort(v.begin(), v.end(), p); 
// sort копирует p и после завершения p.count = 0, хотя массив отсортировали

// Используем std::ref, чтобы передать функтор по ссылке, а не по значению
std::sort(v.begin(), v.end(), std::ref(p)); 
// Теперь p.count = 27
```
Но как они работают? Лучше всего будет взглянуть на их примерную реализацию.
`ref` `cref` принимают свой аргумент по ссылке или константной ссылке и создают экземпляр типа `reference_wrapper`
```cpp
template<typename T>
class reference_wrapper {
    T* data;
public:
    reference_wrapper(T& data) : data{ &data } {}
    
    operator T&() const { return *data; }
    
    reference_wrapper& operator=(const reference_wrapper<T>& other) {
        data = other.data;
        return *this;
    }
};
```
При копировании `reference_wrapper(value)` ссылка на `value` не меняется, а главное определены копирующий конструктор и оператор присвоения, а это значит, что объекты этого типа могут легко инициализироваться повторно в отличии от ссылок. И определен оператор приведения к ссылке и в нужный момент ведет себя, как обычная ссылка.
Итак, когда мы используем для передачи аргумента функции `ref` или `cref`, мы передаем не копию объекта, не ссылку на него, а экземпляр `reference_wrapper`, который внутри себя хранит указатель на передаваемый объект.
#### Решение 2 задачи
Мы можем сделать обертку `reference_wrapper`, которая будет ссылкой на тип, и она умеет все поставленные задачи. 
Пример задачи и ее решение.
Допустим есть список, который хранит `string`. Необходимо найти самую длинную строку.
```cpp
typedef std::reference_wrapper<std::string> string_ref;
    // Список, в котором очень много строк
    std::list<std::string> list; 

    // Временная переменная, а-ля "ссылка" на std::string
    std::reference_wrapper<std::string> t = list.front();
    
    // Очень простой цикл без синтаксиса указателей и итераторов
    for (std::string& i : list) {
        if (i.size() > t.get().size()) t = x; // Копирования не происходит! 
    }
    f.get() // ответ
```
Когда компилятор не может привести тип, приходится вызывать метод `get()`. Этот метод явно возвращает ссылку на “обернутый” объект.
#### Решение 1 задачи 
Если копирование элементов требует избыточных затрат ресурсов, или нужно, чтобы несколько контейнеров размещали одни и те же элементы - приходится использовать “умные” указатели. Но есть и другой вариант. Использование reference_wrapper. 
```cpp
// Исходный контейнер с элементами типа int
    std::list<int> l = {-4, -3, -2, -1, 0, 1, 2, 3, 4};
 
    // Контейнер, хранящий "ссылки" на элементы первого контейнера
    std::vector<std::reference_wrapper<int>> v(l.begin(), l.end());
    
    // Теперь если мы изменим значение в векторе, то они изменятся и в списке.
    v[0].get() = 124;
    std::cout << l.front(); // 124
```
### std::forward
#### Reference collapsing
Как известно, взятие ссылки на ссылку в С++ не допускается, но это иногда может происходить при реализации шаблонов: 
```cpp
template <typename T>
void foo(T t) {
  T& k = t;
}

// вызов функции
int n = 0;
foo<int&>(n);
```
При инстанцировании шаблона `T` установится равным `int&`. Какой же тип будет у переменной `k` внутри функции? Компилятор «увидит» `int& &` — а так как это запрещенная конструкция, компилятор просто преобразует это в обычную ссылку. 
```cpp
/*
 * T = int&;  T&  = int&
 * T = int&;  T&& = int&
 * T = int&&; T&  = int&
 * T = int&&; T&& = int&&
 */
```
#### Forwarding reference
Передавать всегда в `std::ref` не удобно. Хочется, чтобы функции сами понимали какое значение надо передавать дальше. 

То есть если в нас передали `lvalue`, то дальше хотим тоже передать `lvalue`. Передали `rvalue`, дальше хотим передать `rvalue`.
```cpp
template<typename T>
void foo (T &&x) // "Forvanding referece"

// Not a "Forvanding referece"
template<typename T>
void foo (vector<T> &&x)
void foo (int &&x)
```
Если в функцию передали `T` `&&x`, то это единственный случай с Forvanding referece.
Попробуем в `foo` передавать разные значения.
```cpp
template<typename T>
void foo (T &&x) // "Forvanding referece"
int v = 1;
const cv = 2;

foo(10);             // T = int,        x = int&&
foo(v);              // T = int&,       x = int&
foo(cv);             // T = const int&, x = const int&   
foo(std::move(v));   // T = int,        x = int&&
foo(std::move(cv));   // T = const int, x = const int&&
```

#### Perfect forwarding
Если в `foo` передать `rvalue` ссылку, то `x` будет `rvalue` ссылкой, а если `lvalue`, то и `x` будет `lvalue` ссылкой.
Если мы хотим передать такой же тип, как и принимали, то надо передать `static_cast<decltype(x)>(x)`, но это долго и для этого есть `std::forward<T>(x)` или просто `std::forward(x)`
```cpp
template<typename T>
std::forward(T &&x) { return static_cast<T&&>(x); }
```
Также можно сделать и для функций 
```cpp
template<typename Fn, typename Arg>
decltype(auto) wrap(Fn &&fn, Arg &&arg) {
    return std::forward<Fn>(fn)(std::forward<Arg>(arg));
}
```
### Сравнение двух методов
#### `ref/cref`
Мы копируем все элементы и тогда мы спокойно удалять, сразу после вызова, или мы используем `ref` и это наша забота, следить за ними.

#### Perfect forwarding
Все аргументы должны жить все время действия программы.

### declval(auto)
Разберемся сначала, как работает `auto`, затем `declval` и тогда все будет понятно (нет). 
#### auto
Итак, как же `auto` выводит тип? К сожалению, здесь нет простого правила на все случаи жизни, кроме, пожалуй, того, что `auto` при выводе типа в общем случае отбрасывает cv квалификаторы и ссылки. Ниже я перечислю самые важные моменты.
1. ```cpp
   auto val = some_expression;
   ```
   Если тип some_expression T* или const T*, то тип var также будет T* или const T* соответственно. Пока без сюрпризов. Дальше — интереснее. Пожалуй, самое важное с практической точки зрения правило заключается в том, что если тип some_expression — T, const T, T& или const T&, то типом var будет T. Это, впрочем, если задуматься, вполне логично, ведь в этом случае значение, возвращаемое some_expression копируется в var и можно смело писать вот так:
   ```cpp
   auto foo() {
       return boo();
   }
   ```
   Это не работает, если `boo` возвращает ссылку.
   
2. ```cpp
   auto& val = some_expression;
   ```
   В этом случае, ожидаемо, если тип `some_expression` — `T` или `const T`, компилироваться это не будет, так как `lvalue` ссылку нельзя инициализировать `rvalue`. Если тип `some_expression` — `T&`, то и `var` будет иметь тип `T&`. Здесь важным моментом является то, что если тип `some_expression` — `const T&`, то и тип `var` будет `const T&`. Все хорошо, но тогда мы не обрабатываем значения в такой реализации.
   ```cpp
   auto& foo() {
       return boo();
   }
   ```
   
3. **примечание от читающих ночью (Юра)** кажется, здесь произошла копипаста и как работает auto&& не рассказано. Поэтому об этом можно прочитать в 17 билете, там расписано подробно и про вывод типов в общем, и про вывод типов для auto и decltype(auto). Впрочем, здесь ниже про decltype(auto) тоже расписано. По факту, если здесь написать auto&& val = some_expression или auto&& foo() {...}, то вывестись должно норм, но рекомендую при подготовке проверить

   ```cpp
   auto&& val = some_expression;
   ```
   В этом случае, ожидаемо, если тип `some_expression` — `T` или `const T`, компилироваться это не будет, так как `lvalue` ссылку нельзя инициализировать `rvalue`. Если тип `some_expression` — `T&`, то и `var` будет иметь тип `T&`. Здесь важным моментом является то, что если тип `some_expression` — `const T&`, то и тип `var` будет `const T&`. Все хорошо, но тогда мы не обрабатываем значения в такой реализации.
   ```cpp
   auto& foo() {
       return boo();
   }
   ```
Всегда при этом можно сделать 
```cpp
auto foo(int a) -> decltype(boo(a)) {
   return boo(a);
}
```
Но это может быть очень длинным.
#### decltype
Итак, следует различать два основных случая применения `decltype`.
1. `decltype(var)`, когда var — это объявленная переменная (например, в функции или как член класса). В этом случае `decltype(var)` будет иметь в точности тот тип, с которым объявлена переменная.
2. `decltype(expr)`, `expr` — выражение. В этом случае типом `decltype(expr)` будет тип, которое могло бы вернуть это выражение, с той оговоркой, что `decltype(expr)` будет иметь тип `T& (const T&)`, если `expr` возвращает `lvalue`, `T`, если `expr` возвращает rvalue типа `Т` (`const T`) и `T&&` (`const T&&`), если `expr` возвращает `xvalue` (rvalue reference).
```cpp
int i;
const int foo();
int&& foo1();

decltype(i);      // int
decltype(i + 1);  // int
decltype((i));    // int&
decltype(i = 4);  //int&
decltype(foo());  // int
decltype(foo1()); // int&&
```
#### decltype(auto)
При совмещении этих двух особенностей мы получаем правильный результат и выражение 
```cpp
decltype(auto) foo () {
    return boo(); // обязательно надо написать return
}
```
Это будет работать, даже если `boo() -> void`.
Не будет работать 
```cpp
decltype(auto) foo (int x) {
    return(x) // decltype( (x) ) = int& см пример 3 в разделе decltype(expr)
}
```
Мы не можем возвращаемое значение сохранить в переменную
```cpp
decltype(auto) foo (int x) {
    auto a = boo(); // type a = void?
    return a;
}
```

