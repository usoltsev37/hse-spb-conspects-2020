## Билет 11
Автор: Глеб Марьин

### Определения и примеры

Следующие понятия характеризуют код с точки зрения безопасности при работе с исключениями: как плохо будет коду, если выкинется исключение.

- No throw: исключения не кидаются, код всегда работает (или в хлам роняет программу, если не повезло).
  - Хороший пример: a = b; для простых типов.
  - Плохой пример: то же самое для сложных (в случае вектора может не хватить памяти).
  - Плохой пример: ввод-вывод.
  - Пример от автора: деструкторы тоже обычно не кидают, чтобы всегда можно было бы успешно произвести stack unwinding.

- Strong guarantee (сильная гарантия): если исключение и вылетело, то ничего не поменялось, например если оно вылетело из Foo::bar(), то Fo все ещё в корректном состоянии, можно без страха продолжать использовать.
  - Пример: list::push_back. Если памяти не хватило, то исключение вылетело, но список не поменялся вообще. Если упал конструктор копирования, то список не поменялся вообще.
  - Пример: vector::push_back. Если памяти не хватило, то исключение вылетело, но вектор не поменялся вообще. Тонкость: для этого надо, чтобы элементы могли копироваться с гарантирей strong. Или перемещаться, но тогда nothrow.

- Basic guarantee (базовая гарантия): если исключение и вылетело, то не произошло UB, все объекты в каком-то корректном состоянии (инварианты есть), нет утечек и прочих проблем.
  - Пример: vector::push_back, если мы не имеем права копировать/перемещать объекты без ошибок. Правда, всё ещё надо уметь уничтожать объекты.

- No guarantee: если исключение произошло, можно только завершить процесс. Если программа дошла до этого момента, то непонятно как давно случилась ошибка, и что плохого сделано уже, поэтому, чтобы не наломать дров стоит убить программу.

### Невозможность обеспечения basic guarantee на основе no guarantee

Если какой-то код не предоставляет даже базовой гарантии, и наш код использует этот небезопасный код, то наш тоже становится небезопасным, потому что если из плохого вылетит исключение, то мало ли что он попортил, он на то и no guarantee. Таким образом наш код тоже no guarantee.

### Обеспечение строгой гарантии

Этот пример был на тесте, пример может быть не самый хороший, но мораль должна быть понятна.

```C++
struct Foo {
    void removeAll(const Bar &value) {
        if (a && *a == value) a.reset();
        if (b && *b == value) b.reset();
    }
    std::unique_ptr<Bar> a, b;
};
```

Приведенный выше код `Foo::removeAll` не предоставляет строгой гарантии исключений, потому что первый
`Bar::operator==` может кинуть, и `a` будет пустым, а `b` нет - некорректное состояние.
Но его можно переделать так, чтобы предоставлял:

```C++
struct Foo {
    void removeAll(const Bar &value) {
        bool aEq = a && *a == value;
        bool bEq = b && *b == value;
        if (aEq) {
            a.reset(); // не должно кидать
        }
        if (bEq) {
            b.reset(); // поэтому до сюда должно дойти
        }
    }
    std::unique_ptr<Bar> a, b;
};
```

Мораль такова, что все опасные (которые не предоставляют `No throw`) действия стоит делать в начале,
а потом все остальные, так можно добиться строгой гарантии.

### MyString, или простой способ нарушить базовую гарантию

```C++
struct MyString {
    char *data;
    MyString(const MyString &other)
        : data(new char[std::strlen(other.data) + 1]) {
        std::strcpy(data, other.data);
    }
    ~MyString() {
        delete[] data;
    }
    MyString& operator=(const MyString &other) {
        if (this == &other) return *this;  // Если не напишем, то будет UB ниже.
        delete[] data;
        data = nullptr;  // Для аккуратности.
        data = new char[std::strlen(other.data) + 1];
        std::strcpy(data, other.data);
        return *this;
    }
};
```

- Тут есть инвариант "`data != nullptr`": `strcpy/strlen` не работают с `nullptr`, выдают UB. `delete[] nullptr` при этом окей.

- Этот инвариант может нарушиться в `operator=`, если `new char[]` кинул. Тогда деструктор ещё можно вызвать, а вот скопировать эту строчку в другую — UB. Ну то есть можно ещё сказать, что это базовая гарантия и такое "невалидное" состояние, конечно...

- А если бы `data = nullptr` не написали, то был бы UB прям сразу, даже деструктор не вызвать. Это 100% нарушение базовой гарантии, без каких-то оговорок.

### Обеспечение базовой гарантии при помощи RAII

Как сказал Егор в консультации: RAII помогает нам обеспечивать
базовую гарантию очень сильно. Если мы везде используем умные указатели,
везде пишем RAII, везде корректно пишем деструкторы, то базовая
гарантия всегда есть. То есть никогда не нужно писать явно try/catch, просто всегда есть базовая гарантия.

### Гарантии в шаблонах

В шаблонах мы не знаем заранее, какие гарантии предоставляет шаблонный
тип. Поэтому гарантии нашего кода зависят от гарантий этого типа.
Немного особая ситуация с деструкторами:
все ок, если деструктор типа `No throw`.
Если же это не так, то во время `unwinding`-a может вылететь исключение,
произойдет что-то плохое, везде говорят что
`application will terminate`, возможно `std::abort`, или `std::terminate`.
Так что в этом случае я бы сказал, что не будет гарантии исключений,
хотя вопрос философский, и уверен, что эти дебри не нужны для экзамена.

Взято с [isocpp.org](https://isocpp.org/wiki/faq/exceptions#dtors-shouldnt-throw)
> So the C++ language guarantees that it will call terminate() at this point, and terminate() kills the process. Bang you’re dead.

По ссылке можно посмотреть подробнее про обработку исключений.

Если методы класса не предоставляют какой-то гарантии, то мы,
работая с ними, не можем её предоставить. Например, пишем

```C++
template <typename T>
int foo(const T &a, const T &b) {
  if (a == b) {
    return 0;
  }
  T c(std::move(a));
  return 239;
}
```

Тогда гарантия будет определяться как худшая из `T::operator==(const T &)` и `T::T(T &&)`. Соответственно, если мы хотим, чтобы `foo` была
с какой-то гарантией, то нужно её потребовать от вызываемых методов.

### noexcept для функций и методов

Есть спецификатор функции `noexcept`, который говорит, что функция
или метод не может кинуть исключения, синтаксис

```C++
void foo() noexcept {
  some_noexcept_call_1();
  some_noexcept_call_2();
  2 + 2;
}

struct Foo {
  void foo() noexcept {};
};
```

Если внутри такой функции вылетит исключение, то случится ошибка
выполнения, точнее `std::terminate`. Из `noexcept` можно вызывать только `noexcept`
функции и методы, точно также, как с const qualified.
Важно знать, что любая аллокация может кинуть, и все, кто её вызывают.
`new`, `std::make_unique`, `std::make_shared`, везде может вылететь
`std::bad_alloc`, что значит, что на куче не хватило памяти для
выделения места под объект.

### Условный noexcept, оператор noexcept

- Оператор noexcept позволяет узнать, может ли из выражения теоретически вылететь исключение (по спецификаторам noexcept).
- Возвращает true/false на этапе компиляции, не вычисляя выражение.

```C++
int bar()          { return 2; }
// ....
int a = 10;
vector<int> b;
static_assert(noexcept(a == 10));
static_assert(!noexcept(new int{}));   // Утечки не будет: не вычисляется.
static_assert(noexcept(a == foo()));
static_assert(!noexcept(a == bar()));  // bar() не noexcept
static_assert(!noexcept(b == b));      // vector::operator== не noexcept
bool x = noexcept(a = 10);
assert(x);
```

В шаблонах хотелось бы помечать функции и методы noexcept,
если это возможно. Для этого используется условный noexcept.

Можно вызвать оператор внутри спецификатора:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(    // noexcept только при условии...
       noexcept(  // ...что следующее выражение noexcept...
           T(std::move(other))  // вызов move-конструктора T
       )
   );
}
```

Получаем:

```C++
template<typename T> struct optional {
    optional() noexcept;
    optional(optional &&other) noexcept(noexcept(T(std::move(other))));
}
```

Применение. Полезно для vector со строгой гарантией исключений.
Если у элементов is_nothrow_move_constructible, то можно перевыделять буфер без копирований:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);  // Может быть исключение.
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move(data[i]));     // Портим data, боимся исключений.
    data.swap(new_data);                              // Исключений точно нет.
}
```

Иначе мы обязаны копировать. Уже есть готовая функция:

```C++
void increase_buffer() {
    vector_holder new_data = allocate(2 * capacity);
    for (size_t i = 0; i < len; i++)
        new (new_data + i) T(std::move_if_noexcept(data[i]));
    data.swap(new_data);
}
```
