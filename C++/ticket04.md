## Билет 04 "ADL"
Автор: Влад Носивской

Боже, если вы сейчас читаете это на экзамене, потому что вам выпал этот билет, то мои вам соболезнования, это такие дебри, что легче алгебру сдать без подготовки, чем разобраться в этом. Но мы сейчас попробуем. Морально приготовьтесь.

* Для начала разберемся, зачем это нужно, поймем, что мы это используем часто и постараемся не думать о том, как это работает.

    Давайте будем говорить на одном языке. Для этого поймем, что такое lookup. Если вы использовали функцию в коде, во время компиляции ей сопоставится ее объявление. Но объявление нужно для начала найти. Если вы задали с помощью :: область, в которой нужно искать - это будет qualified name lookup.
    
    Но вот если не задали... Тогда компилятор должен угадать, что же вы имели в виду. Например, безобидная конструкция ```std::cout << "Hello world!";``` это уже ADL. Потому что это на самом деле вызов ```std::operator<<(std::ostream&, T)```, но мы нигде не подсказали компилятору, где искать такой оператор, поэтому он отправляется на увлекательные поиски оператора, что само по себе крайне полезно, если не задумываться о том, как он это делает.

* Что же, вы все еще это читаете, значит, ждете чего-нибудь страшного? Тогда давайте разберем этот крайне занимательный код.

    ```C++
    #include <iostream>

    int main() {
        // Это сработает, вы и без меня знаете, но, знаете ли, почему?
        // Как я говорил выше, с одной стороны мы не знаем, что такое std::operator<<( ... ), но
        // ADL для того и создан, чтобы ходить по неймспейсам и настойчиво интересоваться:
        // "А у вас некий operator<<(std::ostream&, const char *) найдется?"
        // В данном случае ему повезет, и в огромном и страшном namespace std ему найдут такой,
        // а ADL не брезгливый, он возьмет подходящую функцию даже у std.
        std::cout << "Hello world!\n";

        // Аналогично сработает и такой пример (это ведь просто другая нотация):
        operator<<(std::cout, "Hello world!\n");

        // Дальше - больше.
        // Следующая конструкция не сработает.
        // А все, потому что ADL начинает работать только на вызовах функций
        // Поэтому мы не найдем определение endl
        std::cout << endl;

        // Внимательный читатель подметит, что endl - тоже функция
        // Но раз так, то мы же можем ее вызвать? Да, можем!
        // На этот раз ADL все же запустится.
        endl(std::cout);

        // Но настолько ли вы внимательный читатель? Предлагаю тест в виде строки:
        (endl)(std::cout);
        // Не работает. Удивлены? Я не знаю. Я уже ничего не знаю и ничего не хочу.
        // А все, потому что (endl) это под-выражение, которое не является вызовом функции.
        // Поэтому у ADL лапки в этом случае.
    }
    ```

Давайте теперь испугаемся немного. А испугаемся мы, потому что ADL имеет 9 вариантов работы, в зависимости от аргументов функции. Если готовы, то зажмурьтесь, глубоко вдохните, мы окунаемся в разбор случаев.

### Преддверие ада.

Это место населено нерешительными людьми, которые бояться проходить дальше. Здесь происходит проверка сначала просто unqualified области видимости, без ADL. Если компилятор увидит какую-то функцию, с тем же именем, что у искомой, которая подходит под один из трех следующих случаев, он решит, что запускать ADL не нужно, и что это та самая функция.


* Объявление функции-члена класса.


* Объявление внутри текущего скоупа (но не using внутри текущего скоупа).


* Объявление, которое не является функцией или шаблоном функции. Т.е. какой-то конфликт имен с объектом другой природы.

Например, в следующем коде не будет запуска ADL, код не скомпилируется.

```C++
namespace bar {

void foo(SomeClass x) {}

}

void foo() {}

int main() {
    void foo();
    SomeClass a(...);
    foo(a);
}
```

Если же ни один из трех пунктов не выполнился, мы переходим на следующий уровень. Здесь будет разбираться каждый аргумент. Каждый аргумент добавляет новые области, по которым будет ходить ADL.

### Круг первый. Лимб.

На этом уровне вместе с некрещенными младенцами и добродетельными нехристианами мы вступим в царство фундаментальных типов. Здесь вместе с Гомером, Аристотелем, Сократом и другими известными личностями обитают инты, даблы и прочие простаки. Они не добавляют в поиск ничего. Да, вы верно поняли, что если в прошлой выкладке SomeClass будет, например, интом, ADL не будет работать, даже если убрать строку ```void foo() {}```

### Круг второй. Похоть.

Для аргументов типа класс (даже таких редких зверей, как union) приготовлен третий круг. Здесь в приятной компании Клеопатры и Елены Прекрасной, они добавляют в область поиска ADL следующие места:

* Сам класс.

* Все его прямые и косвенные базовые классы.

* Если класс является внутренним классом другого класса, то ADL будет искать еще и во внешнем классе.

* Внутренние вложенные пространства имен классов, которые уже попали в планы ADL.

### Круг третий. Чревоугодие.

В царстве Цербера гниют под дождем и градом специализации шаблонов классов. Почему чревоугодие, спросите вы? Потому что такие специализации съедают очень много областей в пользу ADL. А именно, кроме класса аргумента, рассматриваются следующие классы и типы, которые добавляют в область поиска все связанные с ними классы и пространства имен:

* Все типы, которые являются аргументами шаблона, которыми специализировали аргумент. Не включаются в область видимости нетипизированные параметры шаблона и параметры шаблона шаблона (если шаблон нам параметризовали другим шаблоном).

* Все пространства имен, в которые входят параметры шаблона.

* Внимание, сложное для понимания предложения, напрягитесь. ADL добавит все классы, в которых параметры шаблона шаблона являются членами этих классов. (Если они оказываются шаблонами членов класса)


### Круг четвертый. Скупость.

    «Тебе узнать их не дано:
    На них такая грязь от жизни гадкой,
    Что разуму обличье их темно»

Для enum-ов в ADL добавится пространство имен, в котором лежит enum, либо класс, если enum лежит в классе.

### Круг пятый. Гнев.

Вы уже достаточно разгневаны на этот билет? Я вполне. Указатели на тип T или на массив типа T тащат за собой все внутренности типа Т, а также все связанные с этим типом классы и пространства имен

### Круг шестой. Стены города Дита.

Здесь в круге еретиков живут функции. Если они являются аргументами функции, они добавляют все типы аргументов и возвращаемый тип функции, а также все связанные с ними классы и пространства имен.

### Круг седьмой. Город Дита.

На этом кругу обитают насильники. В том числе насильники над вашими мозгами: указатели на функцию-член F класса X. Они затащат с собой тип возвращаемого F, типы аргументов F, и, наконец, сам класс X. И, конечно, все связанные с этими типами классы и пространства имен.

### Круг восьмой. Злопазухи. 

Здесь живут на этот раз поля-члены F класса X. С ними все аналогично, они затащат тип F, класс X и все связанные пространства имен и классы.

### Круг девятый. Ледяное озеро Коцит. 

Мы почти закончили разбирать случаи. Здесь во льдах предательства нам нанесут предательский удар наши любимые функции в качестве аргументов и шаблонные функции. А именно:

Если аргумент является именем или адресным выражением для набора перегруженных функций (или шаблонных функций), каждая функция исследуется по отдельности в наших кругах и добавляет все связанные с ней классы и пространства имен.

Кроме того, если набор перегрузок назван с помощью шаблона, все параметры шаблона, а также параметры шаблона шаблона, а также все связанные с ними пространства имен и классы.

### Занимательные дополнения.

Интересные детали предыдущих выкладок.

* using-и внутри связанных пространств имен игнорируются.

* friend-function's внутри пространства имен, которые объявлены в связанном классе видны для ADL, даже если не видны для других поисков.

### Hidden friend. Практическое пособие по поиску друзей.

Если коротко, то друзей можно найти только через ADL.

Про friend-function's из предыдущего пункта вещь важная, запомните.

```C++
#include <iostream>

namespace ns {
    struct Foo {
        friend void foo(Foo) {}
    };

    // void foo(Foo); // (1)
}
// ...
ns::Foo f;
foo(f); // ok
ns::foo(f); // не ok
```

Из минусов мы теперь обязаны эту функцию передавать только как лямбду. 

Можно раскомментировать (1) и функция станет видна.

### Приключения swap и ADL

Пусть вы написали некую функцию swap. 

Как мы уже понимаем, два примера кода будут вести себя по-разному:

```C++
std::swap(a, b);
```

```C++
using std::swap;
swap(a, b);
```

Во втором случае заработает адская машина ADL, которая сама выберет, какой свап использовать, а выберет она исходя из пространств имен аргументов (как мы уже знаем после прохождения по 9 кругам).

Просто знайте это. Выводов не будет. Восторгаться или отторгать - решать вам.

### Выводы.

* Разработчики C++ люди глубоко в своем сознании преисполнившиеся.

* Пользоваться ADL можно, но могут возникать казусы. В коде ```count(vec.begin(), vec.end())``` аргументы это что:
    
    * vector::iterator

    Или
    
    * typedef int* 

    Ответить сложно.
* Если рефакторите код (перемещаете функции, типы) все может сломаться. И в этом нет никакой магии (только если вы прочитали все 9 кругов).

* Всегда пишите ```using std::swap; swap(a, b)```.

