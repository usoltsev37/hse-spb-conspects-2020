## Билет 22
Автор: Тарасов Денис

Я мог что-то упустить, так что осторожно!

* ### Правило нуля
  Если все поля нашего класса примитивные типы или типы, поддерживающие move-семантику (например вместо обычных указателей использовать `unique_ptr` из стандартной библиотеки, где у всего поддерживается move-семантика), то необходимости в каких-либо дополнительных действиях нет. Не нужно каким-либо специальным образом переопределять деструктор, конструктор копирования/перемещения, оператор присвоения копированием/оператор присваивания перемещением, их можно оставить стандартными, если только вы не хотите делать что-то специфическое.


* ### Ref-qualifier
  В сигнатуры методов можно добавлять следующие модификаторы:

  * `&` - позволяет вызывать метод только от lvalue объектов.

  * `&&` - позволяет вызывать метод только от rvalue объектов.

  Примеры:

  * Например у стека не имеет смысла вызывать метод `push` от rvalue объекта, который просто умрет после этого.
  ```C++
  struct Stack {
      ..
      void push(const T&) &;
  };
  Stack s;
  s.push(..); // Ок
  Stack().push(..); // CE, если нет перегрузки с &&
  ```

  * В `lab_15` у нас создавалась цепочка из временных объектов, другого использования методов класса `enumerator` не предполагалось.
  ```C++
  ..
  struct enumerator {
  public:
      auto drop(int count) && noexcept {
          return drop_enumerator<T>(*this, count);
        }
        ..
  };
  enumerator().drop(0); // Ок
  enumerator en;
  en.drop(); // CE, если нет перегрузки с &
  ```

  * Для вектора, например, можно сделать 3 перегрузки `operator[]`
  ```C++
  struct vector {
      const T& operator[](size_t) const&; // T var1 = v[i];
      T& operator[](size_t) &; // v[i] = var2;
      T&& operator[](size_t) &&; // Объект умрет, поэтому можно соптимизировать
          // и сделать move из нужного элемента.
  };
  ```
  * Если добавили метод `T foo() &` или `T foo() &&`, то они будут конфликтовать с `T foo()` и `T foo() const`.
* ### Типичная реализация конструктора с копировниями

  * Простой пример
  ```C++
  struct Person {
      Person(std::string name) : name_(std::move(name)) {
        ..
      }
      std::string name_;
    };
  ```
  Наш конструктор принимает копию какой-то строки, после выхода из функции эта копия исчезнет, и никем не будет использоваться, поэтому имеет смысл сделать move из нее, чтобы измбежать лишних копироваий. `std::move` здесь по делу, иначе произойдет копирование.

  * Подобные вещи могут происходить и в других методах класса (почему-то в интернете есть примеры лишь на констркуктор, но то же самое можно делать в set-методах, например).

* ### Rvalue-ссылки
  Пояснения что такое lvalue, rvalue и компания должны быть в билете 21. Обычные ссылки привязываются только к lvalue значениям, константные к чему угодно. В C++11 появляются rvalue-ссылки: `Foo &&x = foo();` (это лишь демонстрация синтаксиса, в данной ситуации код не имеет смысла, т.к. объект умрет и `x` сошлется в мертвый объект). Они привязываются только к rvalue (xvalue, prvalue). Важно не путаться с ***forwarding reference*** `template<typename T> void foo (T &&x) // "Forwanding referece"`, см. билет 23.

* ### Правила привязывания ссылок
  * `Foo &f = ..; // lvalue, CE для rvalue`
  * `const Foo &f = ..; // что угодно, попытается продлить жизнь у prvalue`
  * `Foo &&f = ..; // только rvalue`

  После привязки ссылки во всех случаях `f` станет lvalue! `&&` это лишь пометка того, что объект умрет. Все то же самое для аргументов функций. `Foo &&f = ..;`, как говорилось, не имеет особого смысла, оно имеет смысл для аргументов функций: `func(Foo &&f)`, здесь `f` будет жить и им можно пользоваться внутри `func`.

  `const Foo &&f` может привизаться только к `rvalue`, при этом из-за константности из нее нельзя сделать move, который мы обычно применяем к rvalue-ссылкам. Поэтому конструкция бесполезна, но есть какие-то специфические случаи, описаные [здесь](https://www.codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/).

  * Пример Егора
```C++
  Foo f;
  Foo &x = f;
  Foo &&y = std::move(f);
  x // lvalue
  x.field // lvalue
  y // lvalue
  y.field // lvalue
  std::move(x).field  // xvalue
  std::move(y).field  // xvalue
  x.field + 10  // prvalue, если field был типа int (а то вдруг operator+ возвращает ссылку).
```

  * Небольшой пример использования rvalue-ссылки. Возможно, не очень удачный пример. Снова напомню про билет 23, т.к. с шаблонами все сложнее.
  ```C++
  struct Foo {
      ..
      void storeString(std::string &&val) {
          data_ = std::move(val);
      }
      std::string data_;
  };
  ```

* ### Move-конструктор, оператор перемещающего присваивания
  *  Move-конструктор и оператор перемещающего присваивания это просто новые перегрузки.
  ```C++
  struct Foo {
      ..
      Foo (Foo &&other) noexcept : data1_(std::move(other.data1_)),
       data2_(std::move(other.data2_)){
          ..
          /* Сделали что-то нужное для нового объекта и
             перевели other в какое-то новое состояние, если надо. */
      }
      // А еще можно было так
      Foo (Foo &&other) noexcept : data1_(std::move(other).data1_),
  data2_(std::move(other).data2_)) // поле xvalue тоже xvalue

      Foo & operator=(Foo &&other) noexcept {
          // Почистили себя, если надо
          ..
          data1_ = std::move(other.data1_);
          data2_ = std::move(other.data2_);
          // Поменяли состояние other
          ..
          return *this;
      }
      std::unique_ptr<T> data1_, data2_; //  Поля могут быть другими, это лишь пример
      ..
  };
  ```
  При вызове конструктора копирования `stack s(VAL);` вызовется более подходящий в зависимости от категории `VAL`, у move приоритет больше, т.к. он более специфичен, чем `Foo (const Foo &other)`, который можно вызвать от любого выражения.

  * Нам очень хочется иметь гарантию исключений, т.к. после move состояние объектов нам не известно и в случае ошибки скорее всего не получится что-либо гарантировать. Например, `std::vector` требует от move-конструктора `noexcept`. Более подробно можно посмотреть [здесь](https://xinhuang.github.io/posts/2013-12-31-when-to-use-noexcept-and-when-to-not.html).

* ### Правило пяти
  После появления move-семантики знакомое нам правило трех превратилось в правило пяти: к конструктору копирования, оператору присваивания и деструктору добавились конструктор перемещения и оператор присваивания перемещением.

  *  Пример. Считаем, что `Person` валиден, если имя не `nullptr`.
  ```C++
  struct Person {
      char* name;
      int age;
      // Destructor
      ~Person() { delete[] name; }
      // Copy constructor
      Person(Person const& other) : name(nullptr), age(0) {
          assert(other.name != nullptr);
          name = new char[std::strlen(other.name) + 1];
          std::strcpy(name, other.name);
          age = other.age;
      }
      // Copy assignment operator
      Person & operator=(const Person &other) {
          if (&other == this)
            return *this;
          assert(other.name != nullptr);
          char *newName = new char[std::strlen(other.name) + 1];
          std::strcpy(newName, other.name);
          std::swap(name, newName);
          age = other.age;
          delete[] newName;
          return *this;
      }
      // Move constructor
      Person(Person&& other) noexcept : name(nullptr), age(0) {
          swap(*this, other); // Нужно либо писать свой swap, либо swap полей отдельно
      }
      // Move assignment operator
      Person & operator=(Person&& other) noexcept {
          swap(*this, other);
          return *this;
      }
  };
  ```

  * В примере выше можно заменить операторы присваивания на один `Person& operator=(Person other)` и воспользоваться идеей copy and swap, однако возникают проблемы с гарантиями исключений. В этом случае правило пяти становится правилом четырех.

  * Вообще правило пяти нужно достаточно редко, правило нуля работает почти всегда. Возможное разумное использование - обертка какого-нибудь C-кода (вспомним сепульку).
