## Билет 09 "Исключения — основы"
Автор: Чистякова Полина
### Предусловия и постусловия конструктора и деструктора, инвариант объекта

Инвариант объекта - то, что определяет его корректное состояние.
Иными словами что-то, что всегда верно про этот объект.

Пример: ```uniq_ptr<T> a``` - владеет указателем, на основе которого он построен. Никто больше этим указателем не владеет.

Как понятно, пока объект живёт - инвариант выполняется. Отсюда вытекают некоторые уловия:

	Постусловие конструктора - инвариант выполняется
	Предусловие конструктора - поля сконструированны
	Постуловие деструктора - объект корректно уничтожен
	Предусловеи деструктора - инвариант выполняется
### Разные стратегии обработки для двух видов ошибок

Существует 2 типа ошибок - "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать).
Отличаются они тем, что первые совершил программист и сам находит путём отладки кода (и лучше бы он их нашёл), а вторые от него совсем не зависят (например, обращение к несуществующему файлу) и с ними надо научиться справляться.

Первые ошибки обрабатываются просто - можно поставить `assert`'ы и просто ронять программу, когда они происходят, чтобы программист сразу понимал, что что-то не так.
```C++
assert(2+2 != 4);
// программа упадёт и в стандартный поток вывода ошибок (stderr) выведется чисто эта строчка, с пометкой, что она упала.
```

Со вторым типом ошибок сложнее - так просто уже не поступить, надо сообщить пользователю, что же произошло, и, возможно, сохранить какие-то результаты.

Для этого существует несколько стратегий:
 * Вывод сообщения об ошибке сразу, как её встретили:
    ```C++
    void read_people() {
       File *f = fopen(filename, "r");
       if (!f) {
          printf("сообщение об ошибке");
          return;
       }
    }
    ```
    Проблема этого подхода - не всегда надо сразу писать в стандартный поток вывода (например, мы хотим выводить ошибку как-то в графическом интерфейсе)
    + иногда хочется ошибку обработать не тут (например, ошибка на сервере, а сказать надо что-то тому, кто туда обратился)
 * Возвращать код ошибки
   ```C++
   int sqlite3_open(const char *fname, sqlite3A *out); // Возвращаемое значение - код ошибки. Второй параметр - указатель на результат работы функции
   ```
   Проблема конкретно этого подхода сразу видна - надо знать все значения кода, что не очень удобно для программста
 * Почти возвращение кода ошибки - возвращать структуру, в которой может лежать значение OK или Error
 
   *пример на Rust'е*
   ```Rust
     fn Read_people() -> Result<People, String> {
        match open() {
           OK(f) -> {...}
           Err(err) -> return Err(err);
        }
     }
     let f = try!(open());
   ```
   Здесь Result - как раз такая стурктурка. Если ошибок нет, она вернёт значение OK или значение Err в противном случае.
   Проблема этого подхода - каждая функция очень аккуратно прощупывает остальные, всегда готова поймать исключение и, если сама не может её обработать, прокинуть дальше.
 * Кидать исключения
   ```C++
   std::vector<int> read_vector() {
      int n;
      if (!(cin >> n)){
         throw invalid_vector_format();
      }
   }
   
   try {
      read_vector();
   } catch ( invalid_vector_format() &err ) { /* обработка ошибки */ )
   ```
   Данный подход - просто goto решение проблемы

### Исключения: try, catch, throw, где что ставить для обработки ошибок

В предыдущем пункте мы увидели пример использования исключений.
Чтобы его выбросить используется конструкция `throw exception`.

Для обработки исключения существует блок `try/catch`:
```C++
try {
   /*что-то, что может выкинуть исключение, которое мы хотим обработать*/
} catch (/*исключение, которое мы ловим*/) {
   /*обработка исключения*/
}
```
Почему это удобно?

Потому что это помогает не думать об исключениях там, где мы их не можем обработать.
Просто кидаем что-нибудь, что долетит до тех, кто знает, что делать (или не принимаем исключение, а пускаем его дальше).

Небольшие уточнения к синтаксису:
 * у `catch` есть особый синтаксис - `catch (...)` дословно значит - "поймай всё что угодно"
 * В `catch` иногда полезно что-то сделать, а затем прокнуть ошибку дальше (например, если мы хотим проследить жизненный путь ошибки). Осуществляется конструкцией `throw;`
### Вложенные try/catch, несколько catch подряд и почему важно ловить по ссылке

Вложенные try/catch работают также, как и обычные. Поднявшись до try исключение смотрит на все catch - если не находит нужный, летит дальше.
Исключение из catch вылетает во внешний try. Сами блоки проверяются от внутренних к внешним.

```C++
try {
    // вызвали функцию, в которой
    try {
        throw Bar();
    } catch (Foo &err) {
    }
} catch (Bar &err) {
}
```

Ловят исключение по ссылке, потому что очень активно используется иерархия исключений - хотим избежаьт slicing'а.
### Stack unwinding (раскрутка стэка) и уничтожение локальных ресурсов

Как только исключение бросается, оно летит по строчкам вверх (а не вниз, как каждая уважающая себя программа), и уничтожает всё, что встречается ему на пути (вызываются деструкторы).
Когда оно доходит до первого блока try, оно прекращает лететь вверх и идёт к блокам catch.
Там исключение ищет себе подходящий вход. Когда оно его находит - начнается обработка этого исключения. Внутри блока catch считается, что исключения уже нет.

**WARNING** Поскольку во время размотки стека вызываются деструкторы, то всякие указатели не освободят свои ресурсы (не сипользуйте указатели, ага)

### Идиома Resource Acquisition Is Initialization (RAII)

Идиома RAII (Resource Acquisition Is Initialization) берет свое начало в языке С++ и заключается в том, что некоторый ресурс захватывается в конструкторе объекта, и освобождается в его деструкторе. А поскольку деструктор локальных объектов вызывается автоматически при выходе из метода (или просто из области видимости) не зависимо от причины (нормальное завершение метода или при генерации исключения), то использование этой идиомы является самым простым и эффективным способом написания сопровождаемого C++ кода, безопасного с точки зрения исключений.

При этом, если из конструктора вылетело исключение, то использовать этот объект мы уже не сможем. Нам просто не дадут :с
### Примеры исключений из стандартной библиотеки (std::exception и его наследники, bad_alloc)

Самый базовый класс для ошибок - `std::exception`. От него наследуются все остальные (и принято наследовать свои классы ошибок).

Примеры классов ошибок и как они наследуются.

```
std::exception
│   virtual const char *what() const;    
│
└───std::logic_error
│   │
│   └───std::invalid_argument
│   │
│   └───std::out_of_range
│   
└───std::runtime_error
│   
└───my_logic_exception
        *этот класс пользовательский, при большом желании можно не наследовать*
```
