## Билет 12
Автор: Кирилл Бриллинатов

### Строгая гарантия в конструкторах (ctor) и деструкторах (dtor)
#### ctor
В **ctor** обеспечить строгую гарантию исключений очень просто, так как до конструктора у объекта 
не было состояния - его не существовало. Тогда если в конструкторе вылетело исключение, 
то после этого состояние не поменяется. Единственное, надо следить за тем, чтобы не утекали 
ресурсы - этого проще всего добится использованием RAII-оберток. 
```cpp
struct HuffmanArchiver {
  HuffamnArchiver(const std::string& inputFilename, const std::string& outputFilename) 
      : inputFilename_{inputFilename}, outputFilename_{outputFilename} {}
      // если std::bad_alloc вылетело при копировании в outputFilename_, то inputFilename_ корректно удалится
private:
  std::string inputFileaname_, outputFilename_;
};
```

#### dtor 
В **dtor** обеспечение строгой гарантии должно быть выполнено, так как неявно все **dtor** помечены **noexcept**

### Общий алгоритм для проведения остальных операций

В общем случае, чтобы обеспечить строгую гарантию исключений для метода класса, можно провести необходимую операцию в два шага: 
1. Сделать все "кидающие" операции, не меняя состояния класса
2. Обновить (если надо) состояние класса с помощью "не кидающих" операций (например мувами)

```cpp
struct Matrix {
  void setColNRow(int cols, int rows) { 
    data_.resize(rows);
    for (auto& row : data_)  {
      row.resize(cols);
    }
  }
  // Плохая реализация, так как внутри цикла может выкинутся bad_alloc, а состояние объекта уже изменено

  void setColNRow(int cols, int rows) { 
    std::vector<std::vector<int>> newdata(rows);
    std::copy(data_.begin(), data_.end(), newdata.begin()); // копирование векторов
    for (auto& row : newdata) { 
      row.resize(cols);
    }
    std::swap(data_, newdata);
  }
  // Лучше, так как swap по умолчанию noexcept

private:
  std::vector<std::vector<int>> data_;
};
```
### Copy-swap trick
```cpp
struct DataHolder {
  DataHolder(const DataHolder& other) : size_{other.size_} { 
      std::unique_ptr<char[]> newdata(new char[size_]);
      std::memcpy(newdata.get(), other.data_, other.size_);
      data_ = newdata.release();
  }
  
  DataHolder& operator=(DataHolder other) { 
    std::swap(data_, other.data_);
    std::swap(size_, other.size_);
    return *this;
  }
  // При вызове создаетсь копия, того что передали (или мувается, но это видимо здесь неважно), 
  // затем происходит обмен полями с other и так как время жизни other ограничено фигурными 
  // скобаками, то он удалится и вызовется деструктор DataHolder и старый data_ удалится.

private:
  char* data_;
  std::size_t size_;
};
  
```
*Замечание* ```std::unqiue_ptr<T[]>``` для того, чтобы если дальше по коду произойдет исключение не произошло утечки ресурсов. В данном случае ни одна фукнция не кидает исключение (даже std::memcpy), но привычка полезная.

Из-за такой реализации код сильно упрощается.
### Проблемы с move-семантикой
Проблемы возникают, когда мы работаем с объектами, у которых move оператор присваивания или ctor 
не **noexcept**. Особенно сложно становится, когда мы храним такой объект по значению. Так как в 
таком случае, например, в move операторе приходится явно мувать этот объект. Можно скопировать, 
но у объекта может быть некопируемым (бывает достаточно часто). Получается, что иногда такие проблемы 
не получается решить и лучше для своих структур делать move ctor и оператор **noexcept**
#### Вывод
Пример, когда нельзя решить: пишем контейнер, хотим reserve - выделили новую память, туда
надо, либо мувать, либо копироавть. Move-оператор - не **noexcept**, нет ctor коипрования.

Пример, когда можно решить: все тоже самое - но есть ctor копирования, тогда можно полностью все скопировать в новый буфер, потом свопнуть указтели (это **noexcept**)

### pop в stack
При реализации метода pop в классе stack нельзя одновременно вернуть последний элемент и удалить его. До move-семантики нужно обязательно кипровать возвращаемое значение, но тогда во время возврата значения могло кинуться исключение, а состояние объекта уже поменялось.
```cpp
T pop() {
  return data_[--size_];
}
```
Но move-семантика не до конца решает (опять же может быть кидающий move ctor). В связи с этим разделют данную процедуру на две - top и pop
```cpp
void pop() {
  // как-то удалили последний элемент
  --size_;
}

T top() const {
  return data_[size_ - 1]; 
}
// можно добавить rev-qualified перегрузок - из временного стэка можно мувать, так как он умрет все равно.
```

