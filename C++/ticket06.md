## Билет 06
Автор: Никита Абрамов

#### Конвенции именований стандартной библиотеки, отличия stdio.h и cstdio

Язык С++ позволяет использовать всю стандартную библиотеку языка С, но появляется еще и собственная стандартная библиотека. Заметим, что STL (standard template library) - кусок стандартной библиотеки языка C++. Конвенция в стандартной библиотеке C++: заголовок пишется без раcширений (например, без `.h`). Добавил что-то свое в `std` - за парой исключений получил UB. Для стандартных заголовков из C есть два варианта их подключения:

* `<stdio.h>` - попадает в глобальный namespace (`::fopen`), может положить что-то в `std`
* `<cstdio>` - попадает в `std` (`::std::fopen`), может положить что-то в глобальный

Можно использовать оба, но лучше придерживаться одного стиля и использовать один.
`#include <bits/stdc++.h>` — нестандартный заголовок из GCC, зависит от версии, лучше не использовать.

#### Неформатированный ввод-вывод (get, peek, unget, read, seekg/tellg)
Всё ещё есть отличие между текстовым и бинарным режимом: 
`std::ifstream f("a.bin", std::ios_base::in | std::ios_base::binary);` 
Существуют функции, в которых мы не можем никак форматировать наш ввод-вывод, разберем основные из них подробнее.

*  get 
`std::istream::get` - (`cin.get`) - считывает 1 символ/строку в c-style, бывает: 
```C++
int get(); //считывает символ и возвращает его целочисленный код
istream& get (char& c); //можно записать в переменную
istream& get (char* s, streamsize n); // записать в строку в стиле c-style
istream& get (char* s, streamsize n, char delim); /* считывает n - 1 символ или до того,
как встретит разделитель (по умолчанию - перенос строки). 
Деталь - разделитель не извлекается, его потом можно считать
\0 - автоматически добавляется в конец, можно ставить n = 0, тогда - пустая строка*/
istream& get (streambuf& sb); //используется для работы с stream buffer (не разбиралось)
istream& get (streambuf& sb, char delim);
```
если не удалось — `istream::traits_type::eof()` (возвращает End-of-File value, которое для многих стандартных функций    считается, как неверный символ (ни с чем сравнивать тоже нельзя))
*  peek
`int peek();` - возвращает текущий элемент во входной последовательности, но не извлекает его, если установлены флаги ошибок(или устанавливается в момент выполнения, то возвращает `istream::traits_type::eof()`)
*  ungetа
`istream& unget();`  - вначале очищает eofbit (с С++11), возвращает последний символ, который достали, если есть флаги ошибок, то устанавливает failbit и возвращается. Следует работать аккуратно
*  read
`istream& read (char* s, streamsize n);`- считывает символы в буфер (размер - знаковый аналог size_t) (аналог `fread`)
* seekg/tellg
`streampos tellg();` - возвращает текущую позицию. `streampos` кастуется к `int`, для элементов этого типа существуют: 
`!=` и `==`
`istream& seekg (streampos pos);` - устанавливает позицию на следующий символ, который будет доставаться из потока
Пример:
```C++
// get length of file:
    is.seekg (0, is.end);
    int length = is.tellg();
    is.seekg (0, is.beg);
```
#### Форматированный ввод-вывод, отличия от printf (типобезопасность, поддержка пользовательских типов)
Пример для форматированного ввода-вывода
```C++
std::ostream& operator<<(std::ostream& os, int v) {
    return os;
}
std::istream& operator>>(std::istream& is, int &v) {
    return is;
}
std::cin >> x >> y;
(std::cin >> x) >> y; //так его разбирает компилятор, как раз ради этого и возвращаем ссылку
operator>>(operator>>(std::cin, x), y); //можно еще так
```
Стандартная библиотека перегружает операторы для базовых типов (`int`, `double`, `char`, `char*`) и каких-то своих (`std::string`). Форматированный ввод - потому что мы можем сами задавать формат, какой хотим. Разберем пример с добавлением произвольного класса (сразу про реализацию своих операторов ввода-вывода):
```C++
struct BigInt {
};
std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return os << (int)v; // алгоритмический костыль(чтобы не уйти в бесконечную рекурсию)
    return os << static_cast<int>(v); // C++-style алгоритмический костыль
}
```
Обычно, когда есть поля, состоящие из базовых типов, то обходится без подобных костылей.
##### Общие правила  
*  Возвращаем ссылку (неконстантная, потому что поток меняется) на левый параметр, потому что не совсем понятно, что такое скопировать поток, особенно, когда он, например, из файла. Также хочется считывать несколько объектов подряд. 
*  Пишем для базовых классов потоков, если не нужно обратное (например, `istream`, а не `ifstream`). 
*  Сам объект для чтения принимает по неконстантной ссылке, потому что мы в него что-то записываем.
*  Можно делать friend, если хотим доставать какие-то приватные поля у класса.
Но так как обычно friend использовать не любят, потому что это нехорошо отражается на архитектуре (цитата Соколова), то можно писать так:
```C++
struct BigInt {
public:
    std::ostream& operator<<(std::ostream& os) {
        os << v;
        return os;
    }
private:
    int v;
};

std::ostream& operator<<(std::ostream& os, const BigInt &v) {
    return v << os
}
```
#### Реализация своих операторов ввода-вывода, включая обработку ошибок
Разберем теперь более подробно обработку ошибок
У каждого потока есть три бита состояния, которые можно узнать:
* badbit — поток умер: не смог записать байт (место кончилось)
* failbit — не удалось прочитать/записать, но поток жив. Например, неверный формат. Где мы сейчас в потоке — непонятно.
* eofbit — мы уже знаем, что поток закончился (аналогично feof). Например, если в конце файла 123, и мы прочитали число, то мы не знаем, что за пробелом конец потока.

Чтение: .rdstate(), .fail(), .eof(), .bad(), operator bool (отрицание fail) и operator!.
`iostate rdstate() const;` - возвращает комбинацию битов, про которые было сказано раннее
`.fail()` - возвращает `failbit` или `badbit`
`.eof(), .bad()` - возвращает каждый конкретный бит(могут быть реализованы через сравнение с `rdstate()`)

Запись:
* clear() для сброса/перезаписи флагов.
* setstate() для добавления флага.
* На контестах достаточно while (cin >> n)
* Для корректного чтения/записи BigInt стоит не просто читать символы, а ещё и флаги ставить при ошибках.
* Чтобы показать совсем разумную ошибку, обычно надо парсить руками

Можно устанавливать исключения (чтобы они вылетали при проставлении битов)
```
std::cout.exceptions(std::cout.failbit | std::cout.badbit);
std::cin.exceptions(std::cin.failbit | std::cin.badbit);
```
#### Реализация своих манипуляторов (например, `read_le_int32` или `eat`)
Если у нас манипулятор без параметров, то можем просто представлять его как функцию:
`ios_base& hex (ios_base& str);` - пример из std, устанавливает флаг(basefield) на hex и работает с ним.
```C++
ostream &tab(ostream &out)
{
    return out « '\t'; // добавляем tab
}

istream &eatline(istream &in) // убираем строку
{
    while(in && in.get() != '\n')
    {
    }
    return in;
}
```
Если же хотим запускать от чего-то (например, `read_le_int32(x)`), то это похоже на вызов конструктора у объекта, поэтому приходится заводить структуру.
Рассмотрим несколько примеров:
Пример с friend - манипулятором
```C++
struct write_le_int32 {
    explicit write_le_int32(int32_t _val) : val(_val) {} //для read - принимаем и храним все по ссылке
    friend std::ostream& operator<<(std::ostream &os, const write_le_int32 &d);/* const&, чтобы лишний раз не копировать,
 а также, так как у нас состояние объекта меняться не будет -
 мы просто его выведем */
private:
    int32_t val;
};
```
Можно снова избавиться от `friend` с помощью трюка, описанного выше (разумеется, можно использовать не только операторы `<<`, но и `()`, например)
```C++
class expand
{
    expand(short to_expand) : value (to_expand) {}
    ostream &operator()(ostream &) const; //как-то выведем число из цифр в формате слов
private:
    short value;
    static const char *const tens[];
    static const char *const units_and_teens[];
};

ostream &operator <<(ostream &out, expand number)
{
   return number(out);
}
```
